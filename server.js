const express = require('express')
const path = require('path')
const resolve = file => path.resolve(__dirname, file)

// Create a renderer
const { createBundleRenderer } = require('vue-server-renderer')
// The server bundle is generated by vue-ssr-webpack-plugin.
const bundle = require('./dist/vue-ssr-server-bundle.json');
// when using template, vue-server-renderer requires the template to contain comment <!--vue-ssr-outlet--> to inject the rendered app
const template = require('fs').readFileSync('./index.template.html', 'utf-8')
// when using createBundleRenderer, bundle has an entry point which exports a function with a context argument and return a Promise
// https://github.com/GeekyAnts/vue-native-core/tree/master/packages/vue-server-renderer#creating-the-server-bundle
const renderer = createBundleRenderer(bundle, {
	basedir: resolve('./dist'),
  runInNewContext: false, // don't recreate the bundle for each render. Recommended for performance, but watch out for pitfalls (eg. singletons)
  template
})

const server = express()

// serving static resources (not as vue routes!)
server.use('/dist', express.static(__dirname + '/dist'));

server.get('*', (req, res) => {
	const context = { url: req.url }
	console.log('**incoming request: ' + req.url);

  // No need to pass an app here because it is auto-created by
  // executing the bundle. Now our server is decoupled from our Vue app!
  renderer.renderToString(context, (err, html) => {
		//console.log(JSON.stringify(val))
	  //res.status(500).end(JSON.stringify(val))
    if (err) res.status(500).end(JSON.stringify(err))
		console.log(html)
		res.end(html)
  })
  
})

server.listen(3000, function () {
  console.log('SSR app listening on port 3000')
})